{
  "problem_statement": "Given an array of integers, find the maximum sum of any contiguous subarray.\n\nInput Format:\n- First line: n (size of array)\n- Second line: n space-separated integers\n\nOutput Format:\n- Single integer: maximum subarray sum\n\nConstraints:\n- 1 <= n <= 10^5\n- -10^4 <= array[i] <= 10^4\n\nExample:\nInput:\n5\n-2 1 -3 4 -1\n\nOutput:\n4\n\nExplanation: The subarray [4] has the maximum sum of 4.",
  "test_input": "4\n1 2 3 4\n\n5\n-1 -2 -5 -3 -4\n\n1\n-10\n\n6\n5 -8 2 9 -10 3",
  "test_output": "10\n",
  "brute_force_code": "import sys\n\ndef solve():\n    \"\"\"\n    This function reads the input, finds the maximum subarray sum using a brute force approach,\n    and prints the result.\n    \"\"\"\n    try:\n        # Read the size of the array\n        n_str = sys.stdin.readline()\n        if not n_str:\n            return\n        n = int(n_str)\n        \n        # Read the array elements\n        line = sys.stdin.readline()\n        if not line:\n            return\n        arr = list(map(int, line.split()))\n    except (IOError, ValueError):\n        return\n\n    # Initialize max_sum with a very small number to handle cases with all negative numbers.\n    # The sum of the first element is a safe starting point if n >= 1.\n    max_so_far = float('-inf')\n\n    # Iterate through all possible starting points of a subarray\n    for i in range(n):\n        # Iterate through all possible ending points of a subarray\n        for j in range(i, n):\n            # Calculate the sum of the current subarray arr[i...j]\n            current_sum = 0\n            for k in range(i, j + 1):\n                current_sum += arr[k]\n            \n            # Update the maximum sum found so far\n            if current_sum > max_so_far:\n                max_so_far = current_sum\n    \n    # Print the final result\n    print(max_so_far)\n\nsolve()",
  "optimal_attempts": [
    {
      "attempt_number": 1,
      "timestamp": 1761398637.1181104,
      "code": "import sys\n\ndef solve():\n    \"\"\"\n    Reads input, solves the maximum subarray sum problem using Kadane's algorithm,\n    and prints the result.\n    \"\"\"\n    try:\n        # Read the size of the array\n        n_str = sys.stdin.readline()\n        if not n_str:\n            return\n        n = int(n_str)\n\n        # Read the array elements\n        arr_str = sys.stdin.readline()\n        if not arr_str:\n            return\n        arr = list(map(int, arr_str.split()))\n    except (IOError, ValueError):\n        # Handle potential empty lines or malformed input\n        return\n\n    # Kadane's Algorithm\n    # The time complexity is O(n) and space complexity is O(1).\n    # This is the most efficient approach for this problem.\n\n    # Initialize the maximum sum found so far and the maximum sum ending at the\n    # current position with the value of the first element.\n    # The constraint 1 <= n guarantees the array is not empty.\n    max_so_far = arr[0]\n    current_max = arr[0]\n\n    # Iterate through the array starting from the second element.\n    for i in range(1, n):\n        # The maximum sum of a subarray ending at the current position is either\n        # the current element itself (starting a new subarray) or the current\n        # element added to the maximum sum of the subarray ending at the previous\n        # position (extending the previous subarray).\n        current_max = max(arr[i], current_max + arr[i])\n\n        # Update the overall maximum sum if the maximum sum ending at the current\n        # position is greater than what we've found so far.\n        max_so_far = max(max_so_far, current_max)\n\n    # Print the final result.\n    print(max_so_far)\n\nsolve()",
      "verdict": "Accepted",
      "error_message": null,
      "execution_success": true,
      "output_match": true,
      "output_diff": null
    }
  ],
  "success": true,
  "total_attempts": 1
}